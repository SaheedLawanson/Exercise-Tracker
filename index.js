// Add requirements
const express = require('express')
const mongoose = require('mongoose')
const bodyParser = require('body-parser')
require('dotenv').config()

const app = express()

// Render HTML
app.use('/', express.static('.'))
app.get('/', (req, res) => {
    res.sendFile(index.html)
})

// API Implementation

// Connect to mongodb database
mongoose.connect(
    process.env.MONGO_URI,
    {
      useNewUrlParser: true,
      useUnifiedTopology: true
    }
);
  
// Create schema for userdata
let userSchema = new mongoose.Schema({
    username: { type: String, required: true }
})
  
// Create model for userdata
let userModel = mongoose.model('user', userSchema)

// Post to /api/users
app.post('/api/users',
    // body parser middleware to extract info from requests 
    bodyParser.urlencoded({extended: false}),
    // Request handler
    (req, res) => {
        // Initiate a response object
        let responseObj = {}

        // Username is stored in "username" key
        // Add new user to mongodb userModel
        // id is automatically generated by mongodb as _id
        let newUser = new userModel({
            username: req.body.username
        })
        // Save the new User to the userModel
        newUser.save((error, savedUser) => {
            // if there's no error while adding to the userModel
            if(!error) {
                // response object should hold the username and _id
                responseObj._id = savedUser._id
                responseObj.username = savedUser.username
                
                // return the response object
                res.json(responseObj)
            }
        })
    }
)

// Get to /api/users should return an array of all users dictionary
app.get('/api/users', 
    // Request handler
    (req, res) => {
        // Find all users in the databasse
        userModel.find({}, (error, allUsers) => {
            if(!error) {
                // return all the found users
                res.json(allUsers)
            }
        })
    }
)

// Create schema for exerciseData
let exerciseSchema = new mongoose.Schema({
    // User id (id of user that is related to the exercise)
    userId: {type: String, required: true},
    // Description: String
    description: {type: String, required: true},
    // Duration: Number
    duration: {type: Number, required: true},
    // Date: String but not necessary
    date: String
})
  
// Create model for exercise data
let exercise = mongoose.model('exercise', exerciseSchema)

// Post to /api/users/:_id/exercises
app.post('/api/users/:_id/exercises',
  // body parser middle to parse request variables
  bodyParser.urlencoded({extended: false}),
    // Request handler
    (req, res) => {
        // Initiate an empty response object
        let responseObj = {}
        // Store the provided information in the exercise model
        let newExercise = new exercise({
            userId: req.params._id,
            description: req.body.description,
            duration: req.body.duration,
            date: new Date(req.body.date).toDateString()
        })

        //if there was no date provided, use current date
        if(req.body.date === "" || req.body.date === undefined){
            newExercise.date = new Date().toDateString()
        }
        
        // Save the new exercise
        newExercise.save((error, savedObj) => {

            // If there was no error while saving
            if(!error) {
                // Find the user that has the id supplied to the form in the user model
                userModel.findById(savedObj.userId, (error, result) => {
                    
                    // If there was no error while saving
                    if(!error) {
                        // Create items same as the user model items combined with the exercise model items
                        responseObj['_id'] = result._id
                        responseObj['username'] = result.username
                        responseObj['description'] = newExercise.description
                        responseObj['duration'] = newExercise.duration
                        responseObj['date'] = newExercise.date

                        // Post should return the user object plus exercise objects
                        res.json(responseObj)
                    }
                })
            }
        })
    }
)

// Get requests to /api/users/:_id/logs
app.get('/api/users/:_id/logs',
    // Request handler
    (req, res) => {

        // find user with the id supplied in the url
        userModel.findById(req.params._id, (error, user) => {
            // If there was no error while searching the user model
            if(!error) {
                // Find all exercises by attached to this id
                exercise.find({userId: req.params._id}, (error, exercises) => {
                    // If there was no error while searching the exercise model
                    if(!error){
                        // Create response obj and initiate the keys in the order 
                        // they should appear with random values which will later be replaced
                        let responseObj = {_id:'?', username:'?', count: '?', log: '?'}
                        
                        /*
                        The response object would contain the user id, username, a count of all 
                        exercises, a log (Array of all user exercises)
                        */
                        responseObj._id = user._id
                        responseObj.username = user.username


                        // Extract query parameters
                        let min = new Date(req.query.from)
                        let max = new Date(req.query.to)
                        let lim = req.query.limit
            
                        // If there is no query
                        let fromDate = undefined
                        let toDate = undefined
            
                        // If there's a minimum and maximum date set
                        if(min != 'Invalid Date'){fromDate = min}
                        if(max != "Invalid Date"){toDate = max}
                        
                        // if minimum and maximum dates were set
                        if(fromDate != undefined & toDate != undefined){
                            // Filter for dates within the specified min and max
                            exercises = exercises.filter(item => {
                                if(new Date(item.date) >= fromDate & new Date(item.date) < toDate){
                                    return true
                                }
                
                                else {return false}
                            })
                        }
            
                        // Cut down the number of logs to the limit, if a limit was set
                        if(lim){
                            exercises = exercises.slice(0, lim)
                        }
            
                        // Show only the description, duration and date
                        responseObj.log = exercises.map(item => {
                            return {description: item.description,
                                duration: item.duration,
                                date: item.date}
                        })
            
                        // Count the output exercises
                        responseObj.count = responseObj.log.length
                        
                        // return the response object
                        res.json(responseObj)
                    }

                    // If there was an error while searching, log an error message
                    else{console.log('An error occurred')}
                })
            }
            
            // If there was an error while searching, log an error message
            else{console.log('An error occurred')}
        })
    }
)

// Listen for requests
let port = 3000;
app.listen(port, () => {
    console.log(`App is listening on port ${port}`)
})

